---
layout: post
title:  "[NETWORK] TCP/IP를 간략하게 알아보자"
excerpt: "TCP/IP는 무엇이고 어떻게 동작하는가"
categories: [NETWORK]
tags: ['NETWORK']
author: dev-dongwon
comments: true
---



# background

## 회선교환방식 vs 패킷교환방식

### 회선교환방식

- 전화망을 생각하면 쉽다. 송신자와 수신자가 결정되면 **전송하기 전에 먼저 회선을 설정**한다.
- 하나의 통신 경로를 점유하기 때문에 기본적으로 **일대일** 통신만 할 수 있다



### 패킷교환방식

- 고정 경로가 미리 설정되지 않는다.
- 전송은 주고받을 데이터를 잘게 쪼갠 패킷(packet)으로 나눈 후, 다른 데이터 조각들과 **통신 경로를 공유**한다.
- 생각해보자. 회선교환방식은 회선이 미리 설정되어 목적지로 쉽게 갈 수 있지만 패킷은 통신 경로를 공유하기 때문에 어디로 갈 지 알 수 없다. 그래서 패킷에는 데이터의 목적, 주소, 패킷 순서, 제어 정보를 담아 보내게 된다.
- 이게 인터넷이다.



## 네트워크 계층 모델

### 왜 나왔나

- 서로 다른 특성을 갖는 시스템끼리 어떻게 통신하게 할까? 라는 고민에서 나왔다. 그래서 프로토콜을 기능별로 나누고, 역할을 부여했다. 
- 각 계층은 하위 계층의 기능만을 이용하고, 상위 계층에게 기능을 제공한다. 
- 그래서 데이터 전송 시 각 층마다 인식하는 헤더를 붙이게 되는데 이것을 **캡슐화**라 한다. 택배 포장하는 것을 상상하면 이해가 쉽겠다.
- 데이터 전송 후 다시 계층을 올라가게 되면서 헤더를 벗기게 되는데 이것을 **디캡슐레이션**이라 한다. 



### OSI 7계층

![osi-7-layer](http://mblogthumb1.phinf.naver.net/20130221_56/carrena_1361440089865dxb8A_GIF/osi.gif?type=w2)



### TCP/IP 4계층

대다수의 프로그램은 TCP/IP 위에서 통신하고 있다. 가장 성공한 프로토콜이란 말이지. 그래서 인터넷 프로토콜을 따로 떼서 TCP/IP 4계층으로 분류했다. 실질상의 표준이 아닐까.

![tcp/ip-4-layer](https://t1.daumcdn.net/cfile/tistory/995EFF355B74179035)



# TCP

## TCP는 트랜스포트 계층이다

### 트랜스포트 계층의 역할

- 브라우저를 여러 개 켜서 웹 서핑하는 동시에 npm install로 모듈을 설치하는 데 신기하게 데이터가 엉키지 않는다.
- 이렇게 컴퓨터 안까지 들어온 데이터를 분류 후에 각 프로그램까지 전달하는 것이 트랜스포트 계층의 역할이다.
- 분류는 포트 번호로!
- 트랜스포트 계층의 대표적인 프로토콜은 **TCP, UDP**다



### 포트 이야기

트랜스포트 계층에는 인터넷 계층에서 전달한 다양한 종류의 패킷이 들어온다. 어떤 것은 브라우저로, 어떤 것은 노드로, 어떤 것은 게임으로 데이터가 전달되어야 하는데, 이것은 포트 번호로 분류한다.



>  포트 간단 상식
>
> - 0 ~ 65535번까지 이용 가능
>
> - 웰 노운 포트(0~1023번), 레지스터드 포트, 다이나믹 포트 세 종류로 구분
>
> - 웰 노운 포트가 우리가 흔히 사용하는 대표적인 프로토콜 수신 포트 (20번 FTP, 25번 SMTP, 80번 HTTP 등)
> - 클라이언트가 사용하는 포트 번호는 그때그때 다르다 (다이나믹 포트 사용). 자동할당되므로 어떤 번호가 사용될 지는 미리 알 수 없다.



### 브라우저 접속한 후 클라이언트와 서버의 접속 과정

1. 브라우저 포트가 다이나믹 포트로 할당 (웹 서버가 80번에서 대기하고 있다고 가정하자)
2. 웹 서버 80번 포트에 접속 요청
3. 웹 서버가 접속 허용하면 통신 가능 상태가 된다
4. 통신이 종료되면 포트를 반납한다



### 어떻게 상대방을 식별하나?

- 클라이언트 측은 서로 다른 IP 어드레스와 포트 번호를 사용한다. 이것을 조합해서 클라이언트를 식별한다.
- 더불어 클라이언트 IP 어드레스와 포트를 조합해서 기억해둔다.



## TCP, UDP의 가장 큰 차이

### TCP : 정확성이 제일 중요해

수신지에 데이터가 정확히 전달되도록 **전송 속도를 조절**하고 도달하지 않는 데이터를 **재전송**한다

- 통신 환경에 맞춰 데이터 크기를 정하거나 연속된 데이터를 몰아서 보낸다
- 도달하지 않는 패킷이 있다면 재전송을 요청한다



### UDP : 속도가 제일 중요해

VoIP나 동영상 스트리밍 서비스 같이 **속도가 중요한 실시간 통신**이 필요할 때 쓴다

- 전송 속도 조절이나 재전송 요청같은 별다른 처리를 하지 않으니 당연히 속도가 빠르다



## TCP는 어떻게 데이터를 정확하게 전달하나?

- 다시 한 번 상기하자. TCP의 가장 중요한 역할은
  - 전송 속도 조절하기
  - 데이터 재전송하기
- TCP는 데이터 전송에 신뢰성을 더하기 위해 세그먼트 단위로 데이터를 분할한다.
- 이 세그먼트는 데이터 본체에 **TCP 헤더** 가 붙은 형태로 구성된다. 이 헤더에는 포트번호나 일련번호 같은 정보가 포함되어 있다.



### TCP 헤더 구조



![TCP HEADER](https://live.staticflickr.com/3255/2864257365_0dddf45866_z.jpg)

- 간단히 주요 항목만 살펴보면
  - 일련번호 (Sequence Number) : 송신 바이트 수
  - 확인 응답 번호 (Acknowledge Number) : 수신 바이트 수
  - 윈도우 사이즈 (Window size) : 한 번에 수신할 수 있는 데이터 크기
  - 체크섬 (checksum) : 데이터가 훼손되었는지 확인
  - **컨트롤 비트(controle bits)** (조그맣게 URG, ACK 적혀있는 묶음들) : 현재 통신 상태를 표현하는 플래그 

- 모두 데이터 전송이 정확하게 되고 있는지, 훼손되지는 않았는지 구분하는 정보지?



### 컨트롤 비트

- 현재 통신 상태를 표현하는 플래그 역할
- 이 정보를 전달해서 TCP 통신을 제어한다
- 9개의 플래그가 있고, 각각은 1비트의 크기를 가진다
- 주요 플래그를 조금 살펴보면
  - **ACK** : 이전 동작을 확인했어요
  - **SYN** : 접속을 시작할 떄 ON으로 설정
  - **FIN** : 데이터 송신이 완료, 통신 종료를 원해요
  - CWR : 통신 경로가 혼잡하니 전송량을 줄여주세요라고 부탁
  - ECE : 통신 경로가 혼잡해서 수신 못할수도 있어요라고 알림
  - URG : 긴급 포인터에서 이건 당장 처리해야 한다는 것을 알려줌
  - RST : 접속이 강제 중단되었어요 ㅜㅜ



### 3-way handshake

- 위의 컨트롤 비트까지 이해했으면 이건 저절로 이해된다.
- TCP 통신은 커넥션 연결부터 시작하는 데, 이 커넥션 과정은 **3단계**로 이뤄진다. 

- 그래서 쓰리웨이 핸드쉐이크라고 하는데, 커넥션이 맺어지면 데이터를 전송할 수 있는 상태가 되고, 전송이 끝나면 데이터를 끊는다.



- 이 커넥션이 세 번 오가는데 어떻게 정보를 주고받을까? **헤더의 컨트롤 비트**를 이용해 정보를 주고 받는 것이다



![3-way-handshake](https://t1.daumcdn.net/cfile/tistory/225A964D52F1BB6917)



**[STEP 1]**

A클라이언트는 B서버에 접속을 요청하는 SYN 패킷을 보낸다. 이때 A클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다린다

 

**[STEP 2]** 

B서버는 SYN요청을 받고 A클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송한다.

A가 다시 ACK으로 응답하기를 기다린다. 이때 B서버는 SYN_RECEIVED 상태가 된다.

 

**[STEP 3]**

A클라이언트는 B서버에게 ACK을 보내고 이후로부터는 연결이 이루어지고 데이터가 오가게 된다.

이때의 B서버 상태가 ESTABLISHED 이다.

위와 같은 방식으로 통신하는것이 신뢰성 있는 연결을 맺어 준다는 TCP의 3 Way handshake 방식이다.



### 컨트롤 비트 중 sequence number(일련번호)의 역할

- 커넥션을 맺는 과정에서 일련번호는 1씩 증가
- 데이터 전송 시는 여기에 전송한 데이터 바이트 수만큼 더한다
- 데이터 수신 시는 수신한 데이터의 바이트 수만큼을 확인 응답 번호(Acknowledge Number)에 더한다
- 뭔가 복잡한 것 같지만, TCP 헤더에 일련 번호와 응답 번호라는 것이 있어서 이것을 확인하면 몇 바이트 씩 데이터를 주고 받았는 지 알 수 있다.



### 데이터 송신이 실패하면 어떡하지?

- 송신 측에서 일정 시간이 지난 후에도 수신 응답이 오지 않을 경우 실패로 간주, 다시 데이터를 재전송한다.



### 데이터가 너무 많으면 어떡하지?

- 데이터 수신측은 데이터를 임시 보관하는 Buffer 공간이 있는데, 이 공간 사이즈를 **윈도우 사이즈**라는 TCP 헤더에 설정해서 송신 측에 내가 얼마나 받을 수 있는 지 알려준다.



### 데이터가 들어오는 속도보다 컴퓨터가 꾸져서 속도가 느리면 어떻게 하지?

- 수신 측은 버퍼에 패킷을 쌓아 둠과 동시에 버퍼에 쌓인 데이터를 순차적으로 처리한다
- 근데 이게 컴터 성능이 안좋아서 느려질 수가 있단 말이지
- 그럴 때 이 **윈도우 사이즈**의 숫자를 낮춰서 알려주게 된다.
- 이걸 **흐름 제어(flow control)**이라고 한다



### 버퍼가 가득 차면 어떡하지?

- **윈도우 사이즈**가 0으로 설정되고, 일단 데이터 전송을 멈춘다.
- 다시 재개할 시점을 알기 위해 **윈도우 프로브**라는 패킷을 보내고, 수신 측 응답을 받고, 윈도우 사이즈 확인 후에 재개한다.



### 연속된 데이터를 몰아 보내면 전송 속도가 빨라진다

- 생각해보자. 데이터에 대한 응답을 받고 다음 데이터 보내고, 다시 응답받고 데이터 보내고... 이러면 시간이 많이 걸린다.
- 응답을 기다리지 않고 연속된 데이터를 몰아서 보내면 속도가 향상된다



# UDP

확인 없이 오로지 전송만 하는 상남자의 프로토콜.

## TCP와 비교

![](https://www.cloudflare.com/img/learning/ddos/glossary/user-datagram-protocol-udp/tcp-vs-udp.svg)



## 브로드캐스트, 멀티캐스트 기능 : TCP에는 없다!

- UDP에는 하나의 패킷을 여러 수신지에 전달하는 브로드캐스트, 멀티캐스트 기능이 있다

- 브로드캐스트는 파일 공유나 DHCP와 같이 네트워크 내의 여러 컴퓨터나 통신 장비와 정보 교환 시 사용

